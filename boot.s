;************************************************************************
;	HomebrewOS ブートプログラム
;************************************************************************
;************************************************************************
;	マクロ
;************************************************************************
%include	"../include/define.s"
%include	"../include/macro.s"

		ORG		BOOT_LOAD					; ロードアドレスをアセンブラに指示

;************************************************************************
;	エントリポイント
;************************************************************************
entry:
		;-----------------------------------
		; BPB(BIOS Parameter Block)
		;-----------------------------------
		jmp		ipl							; iplへジャンプ
		times	90 - ($ - $$) db 0x90		; 90の位置まで0x90(NOP)で埋める

		;-----------------------------------
		; IPL(Initial Program Loader)
		;-----------------------------------
ipl:
		cli									; 割り込み禁止

		mov		ax, 0x0000					; AX = 0x0000
		mov		ds, ax						; DS = 0x0000
		mov		es, ax						; ES = 0x0000
		mov		ss, ax						; SS = 0x0000
		mov		sp, BOOT_LOAD				; SP = 0x7C00

		sti									; 割り込み許可

		mov		[BOOT + drive.no], dl		; ブートドライブを保存

		;-----------------------------------
		; メッセージを表示
		;-----------------------------------
		cdecl	puts, .s0					; puts(.s0)

		;-----------------------------------
		; 残りのセクタを全て読み込む
		;-----------------------------------
		mov		bx, BOOT_SECT - 1			; BX = 残りのブートセクタ数;
		mov		cx, BOOT_LOAD + SECT_SIZE	; CX = 次のロードアドレス;

		cdecl	read_chs, BOOT, bx, cx		; ax = read_chs(.chs, bx, cx);

		cmp		ax, bx						; if (AX != 残りのセクタ数)
.10Q:	jz		.10E						; {
.10T:	cdecl	puts, .e0					;   puts(.e0)
		jmp		reboot						;   reboot(); // 再起動
.10E:										; }
		jmp		stage_2						; ブート処理の第2ステージへ移行

.s0		db	"Booting...", 0x0A, 0x0D, 0
.e0		db	"Error:sector read", 0

		;-----------------------------------
		; キー入力待ち
		;-----------------------------------
reboot:
		cdecl	puts, .s0
.s0		db	0x0A, 0x0D, "Push SPACE key to reboot...", 0x0A, 0x0D, 0

wait_key:
		mov		ah, 0x10					; // キー入力待ち
		int		0x16						; AL = BIOS(0x16, 0x10);

		cmp		al, ' '						; ZF = AL == ' ';
		jne		wait_key

		cdecl	puts, .s1					; // 改行
		int		0x19						; BIOS(0x19)	// reboot();

		;-----------------------------------
		; データ
		;-----------------------------------
.s1		db	0x0A, 0x0D, 0x0A, 0x0D, 0

ALIGN 2, db 0
BOOT:										; ブートドライブに関する情報
	istruc	drive
		at drive.no,		dw 0			; ドライブ番号
		at drive.cyln,		dw 0			; C:シリンダ
		at drive.head,		dw 0			; H:ヘッド
		at drive.sect,		dw 2			; S:セクタ
	iend

;************************************************************************
;	モジュール
;************************************************************************
%include	"../modules/real/puts.s"
%include	"../modules/real/read_chs.s"

;************************************************************************
;	ブートフラグ（先頭512バイトの終了）
;************************************************************************
		times	510 - ($ - $$) db 0x00
		db	0x55, 0xAA

;************************************************************************
;	モジュール（先頭512バイト以降に配置）
;************************************************************************
%include	"../modules/real/itoa.s"
%include	"../modules/real/get_drive_param.s"

;************************************************************************
;	ブート処理の第2ステージ
;************************************************************************
stage_2:
		cdecl	puts, .s0						; puts(.s0);

		;---------------------------------------
		; ドライブ情報を取得
		;---------------------------------------
		cdecl	get_drive_param, BOOT			; get_drive_param(DX, BOOT.CYLN);
		cmp		ax, 0							; if (0 == AX)
.10Q:	jne		.10E							; {
.10T:	cdecl	puts, .e0						;   puts(.e0);
		call	reboot							;   reboot(); // 再起動
.10E:											; }

		;---------------------------------------
		; ドライブ情報を表示
		;---------------------------------------
		mov		ax, [BOOT + drive.no]			; AX = ブートドライブ
		cdecl	itoa, ax, .p1, 2, 16, 0b0100	;
		mov		ax, [BOOT + drive.cyln]			;
		cdecl	itoa, ax, .p2, 4, 16, 0b0100	;
		mov		ax, [BOOT + drive.head]			;
		cdecl	itoa, ax, .p3, 2, 16, 0b0100	;
		mov		ax, [BOOT + drive.sect]			;
		cdecl	itoa, ax, .p4, 2, 16, 0b0100	;
		cdecl	puts, .s1

		jmp		$								; while (1); // 無限ループ

		;---------------------------------------
		; データ
		;---------------------------------------
.s0		db	"2nd stage...", 0x0A, 0x0D, 0

.s1		db	" Drive:0x"
.p1		db	"  , C:0x"
.p2		db	"    , H:0x"
.p3		db	"  , S:0x"
.p4		db	"  ", 0x0A, 0x0D, 0

.e0		db	"Can't get drive parameter.", 0

;************************************************************************
;	パディング（このファイルは8KBとする）
;************************************************************************
		times	BOOT_SIZE - ($ - $$)	db	0	; 8KB
